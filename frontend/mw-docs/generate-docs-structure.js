#!/usr/bin/env node

/**
 * Script to generate documentation structure from system-admin directory
 * Scans all markdown files and creates TypeScript structure for documentation.service.ts
 */

const fs = require('fs');
const path = require('path');

const SYSTEM_ADMIN_PATH = path.join(__dirname, '../../system-admin');
const OUTPUT_PATH = path.join(__dirname, 'src/app/services/generated-docs.ts');

// Configuration
const MAX_DESCRIPTION_LENGTH = 200;

// Category mapping with icons
const CATEGORY_MAP = {
  'backend': { name: 'üîß Backend', icon: 'üîß' },
  'cfm-compliance': { name: '‚öïÔ∏è CFM Compliance', icon: '‚öïÔ∏è' },
  'demandas': { name: 'üìã Demandas', icon: 'üìã' },
  'docs': { name: 'üìö Documenta√ß√£o Geral', icon: 'üìö' },
  'frontend': { name: 'üé® Frontend', icon: 'üé®' },
  'guias': { name: 'üìñ Guias', icon: 'üìñ' },
  'implementacoes': { name: 'üîß Implementa√ß√µes', icon: 'üîß' },
  'infrastructure': { name: 'üèóÔ∏è Infraestrutura', icon: 'üèóÔ∏è' },
  'regras-negocio': { name: 'üìã Regras de Neg√≥cio', icon: 'üìã' },
  'seguranca': { name: 'üîí Seguran√ßa', icon: 'üîí' }
};

/**
 * Recursively scan directory for markdown files
 */
function scanDirectory(dir, baseDir = SYSTEM_ADMIN_PATH) {
  const files = [];
  const items = fs.readdirSync(dir);

  for (const item of items) {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      // Recursively scan subdirectories
      files.push(...scanDirectory(fullPath, baseDir));
    } else if (stat.isFile() && item.endsWith('.md')) {
      // Get relative path from system-admin
      const relativePath = path.relative(baseDir, fullPath);
      files.push({
        path: relativePath,
        name: item,
        size: stat.size,
        directory: path.dirname(relativePath)
      });
    }
  }

  return files;
}

/**
 * Extract title from markdown content (first H1)
 */
function extractTitle(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    
    for (const line of lines) {
      if (line.startsWith('# ')) {
        return line.replace(/^#\s+/, '').trim();
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not read ${filePath}`);
  }
  return null;
}

/**
 * Extract description from markdown content (first paragraph after title)
 */
function extractDescription(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    
    let foundTitle = false;
    for (const line of lines) {
      if (line.startsWith('# ')) {
        foundTitle = true;
        continue;
      }
      
      if (foundTitle && line.trim() && !line.startsWith('#') && !line.startsWith('[')) {
        return line.trim().substring(0, MAX_DESCRIPTION_LENGTH);
      }
    }
  } catch (error) {
    // Silently fail
  }
  return 'Documenta√ß√£o do sistema';
}

/**
 * Generate documentation structure
 */
function generateStructure() {
  console.log('Scanning system-admin directory...');
  const files = scanDirectory(SYSTEM_ADMIN_PATH);
  console.log(`Found ${files.length} markdown files`);

  // Group files by top-level directory
  const grouped = {};
  
  for (const file of files) {
    const topDir = file.directory.split(path.sep)[0];
    if (!grouped[topDir]) {
      grouped[topDir] = [];
    }
    grouped[topDir].push(file);
  }

  // Generate TypeScript structure
  const categories = [];

  for (const [dir, dirFiles] of Object.entries(grouped)) {
    const categoryInfo = CATEGORY_MAP[dir] || { 
      name: `üìÑ ${dir.charAt(0).toUpperCase() + dir.slice(1)}`, 
      icon: 'üìÑ' 
    };

    const docs = dirFiles.map(file => {
      const fullPath = path.join(SYSTEM_ADMIN_PATH, file.path);
      const title = extractTitle(fullPath) || file.name.replace('.md', '');
      const description = extractDescription(fullPath);
      
      return {
        id: file.path.replace(/\//g, '-').replace('.md', '').toLowerCase(),
        title: file.name,
        fullTitle: title,
        category: categoryInfo.name.replace(/^[^\s]+\s/, ''), // Remove emoji
        path: `system-admin/${file.path}`,
        description: description,
        size: `${Math.round(file.size / 1024)}KB`
      };
    });

    categories.push({
      name: categoryInfo.name,
      icon: categoryInfo.icon,
      docs: docs
    });
  }

  // Sort categories by name
  categories.sort((a, b) => a.name.localeCompare(b.name));

  return categories;
}

/**
 * Generate TypeScript file
 */
function generateTypeScriptFile(structure) {
  const content = `/**
 * Auto-generated documentation structure from system-admin directory
 * Generated on: ${new Date().toISOString()}
 * Total documents: ${structure.reduce((sum, cat) => sum + cat.docs.length, 0)}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Run: npm run generate-docs to regenerate
 */

import { DocCategory } from '../models/doc-item.model';

export const SYSTEM_ADMIN_DOCS: DocCategory[] = ${JSON.stringify(structure, null, 2)};
`;

  fs.writeFileSync(OUTPUT_PATH, content, 'utf-8');
  console.log(`\nGenerated: ${OUTPUT_PATH}`);
  console.log(`Total categories: ${structure.length}`);
  console.log(`Total documents: ${structure.reduce((sum, cat) => sum + cat.docs.length, 0)}`);
}

// Main execution
try {
  const structure = generateStructure();
  generateTypeScriptFile(structure);
  console.log('\n‚úÖ Documentation structure generated successfully!');
} catch (error) {
  console.error('‚ùå Error generating documentation structure:', error);
  process.exit(1);
}
